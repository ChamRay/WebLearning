# 1、props

~~~
作用范围：父子之间

props 子组件声明接受属性三种写法
	父可以给子传输  非函数和函数
		非函数数据 就是父传给子
		函数数据   实际是父获取子的数据
	特殊：路由配置props(三种) 路由组件之间没有标签，但是可以把参数通过路由映射为属性
		布尔值：true 把路径params参数映射为要显示的组件内属性
		对象：{name:'xxx'} 只能映射传递额外的静态的数据，一般不用
		函数：props:(route)=>{} 自己手动映射params参数和query参数，成为要显示的组件内属性
		
		如果不用props，那么组件内要用数据必须要写成this.$route.params.xxx this.$route.query.xxx
~~~

# 2、自定义事件

~~~
作用范围：
	原生dom事件
		事件类型：固定的几个 click、mouse-leave... 修饰符.native=''
		回调函数：自己定义的
		触发：触发了事件去调用，系统调用浏览器去调用
		event事件：默认传递event事件对象
	自定义事件：
		事件类型：无数个
		回调函数：自己定义的
		触发：自己去调用（通过this.$emit.xxx）
		event事件：默认传递的是自己给的参数（有就有，没有就没有）
	自定义事件添加到html标签上无意义；添加到组件标签上没问题，自定义事件回调函数的默认参数有自己决定
	自定义事件得在子组件内部当中，去使用$emit调用
	
原生dom事件在html标签和组件标签上的区别：
	在html标签上添加就是原生的dom事件
	在组件标签上添加的就是自定义事件，想成为原生的事件得添加修饰符.native，就是把原生dom事件添加到组件根元素上（事件委派了）
vue自定义的事件在html标签和组件标签的区别
	在html标签上添加自定义上无意义
	事件名可以任意，也可以和原生的dom事件名相同，但是是自定义的
~~~

# 3、全局事件总线

~~~
作用范围：任意场合
全局事件总线的角色标准，本质是一个对象
	1、所有的组件队形都可以看到它
	2、可以使用$on和$emit方法
怎么添加事件总线
	1、安装总线
	2、在接受数据的组件当中，获取总线给总线绑定自定义事件 this.$bus.$on
	3、在发送数据的组件对象当中，获取总线触发总线身上绑定的自定义事件 this.$bus.$emit
~~~

# 4、v-model深入

~~~
v-model可以理解为是 :value='msg' @input='msg=$event.target.value'的一个简写方式
									读数据				写数据
v-model通常用在表单类元素，但是v-model也可以用在组件标签身上进行数据通信
	1、父组件通过value属性传递给子组件，子组件内部ubput，value使用的是传递过去的数据
	2、父组件添加了一个自定义的input事件，这个事件是需要子组件内部触发的
	3、子组件内部触发了自定义的input事件，会传递默认值给父组件当中的$event
	4、父组件当中的msg就会被更改为子组件传递过来的数据
	
总结：
	v-model不但可以用在html的表单类元素上，还可以用在组件标签身上使用
	组件标签内部一般都是有表单类元素的
	它适用的场景是父子之间，最终达到父子数据同步的效果
~~~

# 5、.sync修饰符实现父子数据同步

~~~
父子传递数据：
	如果传递的是对象数据类型，对子的改变也会改变父中的数据
	如果传递的是基本数据类型，对子的改变不会改变父中的数据
父子传递数据同步情况：
	父组件当中传递给子组件，子组件使用
	子组件当中药修改父组件的数据，必须触发父组件基于组件绑定的自定义事件
	子组件触发自定义事件传递过来新的数据，父组件更改
	父组件当中数据更改之后，重新传递给子组件，子组件也就发生变化了
通过.sync进行数据同步：
	$emit('update:xxx',function())  子组件触发的事件名称必须是这样->update:xxx
	:xxx.sync='dataSource' 父组件向子组件传值
使用v-model可以直接实现数据同步

v-model和.sync区别：
	都可以实现父子组件数据同步,对于使用有一下约定成俗的约定
	1、v-model是三各自组建当中有表单类元素的时候使用
	2、.sync是当子组件当中不是表单类元素的时候使用
~~~

# 6、扩展dbclick事件(双击事件)

~~~
组件标签中 添加click事件可以触发，dbclick事件不会被触发，所以在使用dbclick事件的时候需要加native修饰符
原生dom中click和dbclick都可以触发
~~~

# 7、$attrs和$listenners

父向子传递数据

~~~
$attrs和$listenners主要是用来让我们根据已有的组件封装自己的组件，对自定义组件灵活传递属性

this.$attrs拿的是除了class属性以及props接收过的属性之外，所有的属性组成的一个对象
this.$listeners 父组件当中给子组件标签绑定的所有自定义事件监听组成的对象
可通过props提前提取不需要获取的数据

~~~

# 8、$children和$parent及$refs

~~~
$refs：直接在父组件中操作子组件对象
	this.$refs.xxx 其实放在html标签身上就是这个dom元素
$children:拿到所有的子组件对象组成的一个数组
	//慎用：原因是拿到这个数组之后数组内部子组件对象先后顺序不定
	this.$children.forEach(item =>{})
$parent:拿到父组件中的数据
	//也要慎用，子组件被多个父组件复用，那么这个方式是没办法使用的
	this.$parent.xxx
~~~

# 9、mixin混入

~~~js
可以把任意组件对象混入到混入对象当中，把重复的代码定义到mixin中，被任意对象调用;即封装公共代码，提高代码的复用性，降低重复代码
export default xxxMixin = {
  data(){
    
  },
  created(){},
  methods:{
    
  }
}

使用时：
import xxxMixin from './xxxMixin'
	在组件对象当中配置混入属性
	mixins:['mixinName']
~~~



# 10、作用域插槽

~~~
数据是在父组件当中的，数据是要给子组件去展示的(v-for)
展示的过程当中，数据的结构是由父组件决定的
	子组件通过props接收父组件传过来的数据，通过v-for展示数据;并通过slot标签结构化传来的数据结构,并通过标签中的:todo属性给父组件回传数据
	父组件通过属性slot-scope接受子组件的回传数据，传到该属性的标签
~~~

# 11、vuex

~~~
5个核心概念
	state
	mutations
	actions
	getters
	modules：用来做模块化，方便管理
~~~



# 12、消息的订阅和发布（PubSubJS）

~~~
参考github的官方说明文档

improt 'PubSub' from 'pubsub-js'
cont PubSub = require('pubsub-js');
~~~

