#  1、VUE简介

## 1.1 vue是什么

vue是尤雨溪开发的一种快速开发网页的 **渐进式** JS框架 ，是结合众多插件的一种前端开发一体化框架

~~~
插件：
	官方插件：vuex vue-router ...
	第三方插件：为了更方便使用的插件,如axios
	
特点：
	数据为尊 动态显示页面
~~~

## 1.2 初探vue

~~~html
改变标签中的数据

<body>
<div>
    <p id='pp'>嘿嘿</p>
</div>

<script>
//原生
    let str = '我爱你'
    let pp = document.getElementById('pp')
    pp.innerHTML = str
    
//jQuery
    $('#pp'),html(str) //效率和原生一样
    
//vue版本 性能是最好的
    
    const vm = new Vue({
        //配置对象
        el:'#app', //挂载点是上面的div
        data:{
            str:'我爱你'
        }
    })
</script>

    <div id='app'>
    	<p id='pp'>{{str}}</p>
    </div>    
// vue采用了文档碎片的方式，所以性能比原生要好
</body>
~~~

## 1.3 Vue的基本使用

~~~js
1、引入vue.js
2、在body当中必须写一个挂载点
3、实例化一个Vue的实例化对象，和挂载点进行挂载
4、请求获取回来的数据，是配置对象当中的data

/*
函数首先是函数  函数还是函数对象
函数是由两个角色 函数可以当函数用() 也可当对象用 函数.属性

函数当函数用可以有多种用法：							  this
	1、普通函数调用  直接()							 window
	2、构造函数调用  new ()						  实例化对象
	3、方法		 a.b()							 调用的方法的对象
	4、回调函数		自己不用						 时间的回调代表事件源
	5、call apply  让一个对象借用另外一个对象的方法		自己给定的对象
	6、箭头函数		i=>{}							外层执行上下文的this	
*/

//挂载点一旦被vn挂载，那么内部就不是我们单纯的html，被称为模板
/*
模板是由两部分组成  html+js
模板语法  指令和插值
指令是用来修改模板当中标签的（属性  内容  样式）
插值是专门用来修改模板当中标签的内容的 {{}}
*/
cont vm = new Vue({
    el:'#app' //被称为挂载点，本质上是一个css的选择器字符串，标识这vm要和谁去绑定挂载
    data:{
    	msg:'我爱你'
	}
                  
    /*
    vm对象和传递的配置对象不是一个对象
    数据代理：使用vm代理了配置对象当中的data的对象，vm身上也有和data当中同名的属性，模板当中访问的都是vm身上的属性
    vm代理了data当中的数据，找vm获取数据其实最终还是拿的data当中的属性值
    修改vm的数据本质是在修改data当中的数据
    */
})
~~~



## 1.4 数据的绑定和事件的添加

~~~vue
<a v-bind:href='url'></a> 
<button >
</button>
/*
v-bind 是数据绑定指令 可简写成  : 
v-on   是事件监听指令 可简写成  @ 
一旦用了指令，那么这个被指令使用的属性，属性值就是js代码了，而原本的""不再代表字符串的边界
*/
<script>
cont vm = new Vue({
    el:'#app' //被称为挂载点，本质上是一个css的选择器字符串，标识这vm要和谁去绑定挂载
    data:{
    //这里是专门存放数据的
    	msg:'我爱你',
    	url:'www.baidu.com'
	},
    methods:{
    //这里是专门存放方法的
    	test(){
    
		}
    }
})
</script>
~~~

## 1.5 双向数据绑定

双向数据绑定必须要有表单标签才能生效；双向数据绑定可以在页面标签中和data中在一方改变时，另一方就会改变

~~~vue
<form>
  <input :value='msg'></input>
		<!--单向数据绑定-->
  <input v-model='msg'></input>
		<!--双向数据绑定-->
</form>

<script>
  /*
  双向数据绑定 一般情况下只针对表单类元素才使用双向数据绑定
  MVVM 说的就是双向数据绑定  V代表View 就是我们的页面 VM代表的就是Vue的实例化对象
  	双向数据绑定：数据可以从data流向页面 页面的数据被更新，也会从页面流向data（当data的数据被更新只有，又会重新流向页面）
  */
	cont vm = new Vue({
    //el:'', 一般情况挂载都是书写配置项
    
    //data可以是对象，也可以是函数
    data(){
      return{
        msg:'我爱你'
      }
    }
  }).$mount('#app')//挂载的标准写法

</script>
~~~

## 1.6 Object.defineProperty

~~~vue
这个方法在为对象添加或者修改  属性为响应式属性

<script>
	let obj = {
    lastName:'我',
    firstName:'爱你'
  }
  
  obj.fullName = '我-爱你'
  
  obj.firstName='不爱你'
  //做不到修改firstName或lastName就会改变fullName属性
  
  Object.defineProperty(obj,'fullName',{
    get(){
      //当访问对象的fullName属性的时候
      return this.firstName+'-'+this.lastName
    },
    set(val){
    	//当设置对象的fullName属性的时候
      let arr = val.split('-')
      this.firstName = arr[0]
      this.lastName = arr[1]
  	}
  })
  obj.fullName = '我-不爱你'
  
  //模拟数据代理
  let vm = {}
  let data = {msg:'我爱你'}
  
  Object.defineProperty(vm,'msg',{
    get(){
      retrun data.msg
    },
    set(val){
      data.msg = val
    }
  })

</script>
~~~

# 2、vue数据特性

## 2.1 计算属性和watch监视的使用及区别

~~~vue
<div>
  <p><!--第一种 直接使用数据模板；数据模板中，this全部指向vm，只不过模板当中的this可以省略-->
    {{firstName}}
  </p>
  <p><!--第二种，封装函数来调用-->
    {{firstName}}
  </p>
  <p><!--第三种，封装函数来调用-->
    {{fullName}}
  </p>
  <p><!--第四种，监视属性-->
    {{fullName}}
  </p>
</div>

<script>
	cont vm = new Vue({
    //el:'', 一般情况挂载都是书写配置项
    
    //data可以是对象，也可以是函数
    data(){
      return{
        firstName:'wo',
        lastName:'aini'
        fullName:''//监视的时候必须有这个属性，属性值是什么不确定，后面根据监视去给它赋值
      }
    },
    computed:{
      //当需要一个数据，但是这个数据此时又没有，并且这个数据可以由目前已有的数据计算而来；此时就可使用计算属性
      fullName:{
        get(){
          return this.firstName+"-"
        },
        set(){
          //结合情况进行使用
        }
      },
      //如果计算属性只有get()方法，计算属性可以简写成下面样式
      fullName(){
        return this.firstName+"-"
      }
      //使用方法去获取数据和使用计算属性去获取数据的区别
      /*
      方法使用了几次，方法就被调用几次
      计算属性不管使用了几次，其get方法只被调用一次，因为计算属性是有缓存的
      */
    },
    watch:{
      //监视的数据必须要存在(在data中存在)，而且是可以变化的
      firstName:{
        //这个对象是一个配置对象
        handler(newVal,oldVal){//这是个属性，属性名和参数名都是固定的
          this.fullName = newVal +'-'+this.lastName
          setTimeout(()=>{
            this.fullName = '呵呵'
          },1000)
        },
        immediate:true//配置这个配置项的作用是无论监视到属性发生不发生变化，都要强制的执行一次回调
      }
    },
    methods:{
      getFirstName(){
        //在vue中所有的函数内部的this都指向vm，因为这些方法或者函数都会被vm代理
        return this.firstName
      }
    }
  }).$mount('#app')//挂载的标准写法

  //watch的外部写法
  vm.$watch('lastName',function(newVal,oldVal){//oldVal此时作为一个函数等待被赋值
    //this决定了是否可以使用箭头函数，没有this的时候不能用
    this.fullName = this.firstName +'-'+newVal
  })
  /*
  watch和computed的区别
  计算属性：一般是没有这个值但是想用这个值，那么根据已有的去做计算
  监视属性：一般监视属性，监视的属性已经后期要更改的属性都必须有；
  通常能用计算属性的都能用监视属性去解决，但是能用watch解决的computed不一定能解决
  
  computed函数当中只能使用同步返回数据，而watch函数可以异步返回数据
  */
</script>
~~~

## 2.2 列表渲染

~~~vue
<body id='app'>
  <li v-for="(person,index) in persons" :key='person.id'>{{person.name}}</li>
</body>


<script>
new Vue({
	el:'#app',
  data:{
    persons:[{
      id:1,name:'lihu',age:23
    }]
  }
})
  
</script>
~~~

## 2.3 数据的响应式

~~~vue
<body id='app'>
  <li v-for="(person,index) in persons" :key='person.id'>{{person.name}}</li>
</body>


<script>
  Vue.config.productionTip = false //消除启动浏览器的生产提示信息
  
const vm = new Vue({
	el:'#app',
  data:{
    persons:[{ id:1,name:'lihu',age:23 },
             { id:2,name:'lihu',age:23 }]
  }
})
  /*
  vue当中处理响应式数据对于数组和对象是不一样的
  
  1、如果修改的是对象的属性，随便改，都是响应式的
  因为Vue一开始就为data当中所有的属性通过Object.defineProperty添加了get和set
  
  2、数组修改的时候，必须使用特定的几个方法才能是响应式，如果直接通过下标操作数组的数据，
  不是响应式的（即数据发生了改变，但是页面没有响应）
  
  为什么数组的方法可以是响应式的？
  此splice非原生的splice，Vue当中给数组部分方法添加了修改页面的功能（重写数组的方法）
  
  总结：vue在对待数组和对象的时候处理响应式数据是不一样的
  */
</script>
~~~

## 2.4 列表的过滤

~~~vue
<body id='app'>
  <li v-for="(person,index) in persons" :key='person.id'>{{person.name}}</li>
</body>


<script>
  Vue.config.productionTip = false //消除启动浏览器的生产提示信息
  
const vm = new Vue({
	el:'#app',
  data:{
    persons:[{ id:1,name:'lihu',age:23 },
             { id:2,name:'lihu',age:23 }]
  },
  computed:{
    newPersons(){
      //从vm身上获取keyword和persons
      let {keyword,persons} = this
      //根据获取的这两个数据计算新的数据
      /*函数和方法最主要的是三要素
      功能 从原数组中过滤出一个新数组
      参数 回调函数（同步的回调）
      		回调函数的参数：当前项，当前项的索引，当前项的数组
      		功能：对遍历的每一项执行回调函数
      		返回值：返回的是一个布尔值(布尔值，条件表达式)，根据这个布尔值的真假来决定要不要收集到新数组当中
      返回值 返回的是新的数组
      */
      let arr = persons.filter((item,index)=>{
        return item.name.indexOf(keyword)!==-1
      })
      let arr1 = persons.filter((item)=>item.name.indexOf(keyword)!==-1)
      
    }
  }
})
  
</script>
~~~

## 2.5 条件渲染

~~~vue
<body>
  <image src='' v-if='true'>表白成功</image>
	<image src='' v-else='false'>表白失败</image>
  
  <image src='' v-show='true'>表白成功</image>
	<image src='' v-show='false'>表白失败</image>
</body>

/*
v-if 和 v-show 都可以达到条件渲染的效果，但是他们的是由很大区别的，后期两个用得都比较多

v-if条件渲染的时候，条件为真的可以被渲染，条件为假的不渲染，起始条件为假的元素根本不存在dom上（内存中没有）
v-show条件为真的被渲染，条件为假的不渲染，但是它是真实在dom上存在的，知识采用样式display:none去做的切换（内存中有）

切换的频率非常高，用v-show
切换频率不高，用v-if
*/
 
~~~

## 2.6 强制绑定样式

~~~vue
<body id='app'>
  <!--第一种情况 我不知道这个元素用得是哪个类，用哪个类是后台设置的数据-->
  <!--动态绑定class以后，静态class仍然可以使用-->
  <p :class='MyClass'>
  </p>
  <!--第二种情况 我不知道这个元素用得是哪个类，用哪个类是后台设置的数据-->
  <p :class='{classA:isA,classB:isB}'>
  </p>
  <!--第三种情况 一个元素一下子有好多个确定的类-->
  <p :class="['classA','classB','classC']">
  </p>
  
  <p :style="{style}">//
  </p>
</body>


<script>
  Vue.config.productionTip = false //消除启动浏览器的生产提示信息
  
const vm = new Vue({
	el:'#app',
  data:{
    MyClass:'',
    isA:true,
    isB:true,
    style:'style'
  }
})
  
</script>

<style>
  .classA{
    
  }
  .classB{
    
  }
  .classC{
    
  }

</style>
~~~

## 2.7 绑定事件监听相关

~~~vue
<body id='app'>
  <!--第一种 事件监听的完整写法-->
  <button v-on:clicl='test1'></button>
  <!--第二种 事件监听的简写-->
  <!--在vue的模板当中，事件回调函数在调用的时候可以传递$event，名字不能随意改，这个东西就是事件对象-->
  <button @click = 'test($event)'></button>
  <!--第三种 事件在添加的时候除了事件对象之外还要传递自己的参数的时候必须写$event 参数无先后-->
  <button @click = 'test('selfPara',$event)'></button>
  <!--传递自己的参数，默认的事件会被覆盖-->
  <button @click = "test('selfPara')"></button>
  <!--第四种 vue事件当中阻止冒泡-->
  <button @click = 'outer'></button>
  <button @click = 'inner'></button>
  <!--事件描述符，直接阻止冒泡-->
  <button @click.stop = 'inner'></button>
  <!--事件当中取消浏览器默认行为，prevent事件描述符取消浏览器默认行为-->
  <button @click.prevent = 'inner'></button>
  <!--键盘事件都用在表单类元素或者document身上-->
  <!--浏览器打开页面直接打开四个元素 document 初始包含块  html  body-->
</body>
<script>
  Vue.config.productionTip = false //消除启动浏览器的生产提示信息
const vm = new Vue({
  data:{
    MyClass:'',
    isA:true,
    isB:true,
    style:'style'
  },
  methods:{
    /*
    事件对象：
    什么是事件对象？
    回调函数 自己定义 自己没用 最后执行了（系统指定（浏览器内核））
    系统调用回调函数的时候默认传递了一个实参，这个实参就是我们所说事件对象
    事件对象：是这一次事件触发后相关的所有一切心思被封装成一个对象
    为什么浏览器调用回调要传递事件兑现个，是为了防止用于在函数内部用到这次事件相关的信息
    */
    test1(event){
      console.log(event.target.innerHTML)
    },
    outer(){
      console.log('waibu')
    },
    innser(event){
      console.log('内部')
      event.stopPropagation();//阻止冒泡
    }
  }
}).mount("#app")
  
</script>
~~~

## 2.7 自动收集表单数据

~~~vue
<body>
  <div id='app'>
    <!--v-model实际绑定的值是value中的值-->
    <input type='text' value='username' v-model='userInfo.username'/>
    <select>
      <!--value动态绑定值，key是选项展示的顺序-->
    	<option :value='city.id' v-for='(city,index) in citys' :key='city.id'>{{city.name}}</option>
    </select>
  </div>
</body>

<script>
cont vm = new Vue({
  data(){
    return:{
      userInfo:{
        username:''
      }
    }
  }
}).mount('#app')
</script>
~~~

# 3、Vue方法特性

## 3.1 内置指令

~~~vue
v-html:解析字符串中的标签，并展示其余内容
v-text:不解析字符串中的标签，展示所有文本内容
v-on:绑定事件
v-model:
v-show:条件渲染（存在内存）
v-if:条件渲染（不存在）
v-else:
v-for:列表渲染
v-bind:单向绑定数据
ref:是vue当中给我们提供的一个标识数据，实例的$refs内部可以获取到

<body>
  <p ref='pp'></p>
</body>
<script>
	test(){
		this.$refs.pp.innerHTML='我爱你'//通过这个标识获取dom元素，标签中要定义有ref属性
	}
</script>
~~~

## 3.2 生命周期和钩子函数

### 3.2.1 上下文回顾

~~~js
function Dog(name,age){
  this.name = name
  this.age = age
}
let d1 = new Dog('旺财',3)
console.dir(Dog)

~~~

### 3.2.2 生命周期

![Vue 实例生命周期](https://cn.vuejs.org/images/lifecycle.png)

~~~vue

<script>
new Vue({
  template:'<p ></p>',//在确认挂载点和初始化之后解析模板，没有模板以el的outerHTML作为模板
  data(){
    return:{
      
    }
  },
  methods:{
    destroy(){
      this.$destroy()//必须在某个特定的场合下，自己手动调用vm.$destroy方法，才能进入销毁的阶段
    }
  },
  //1、查找挂载点
  //2、初始化阶段有两个钩子 beforeCreate created
  beforeCreate(){
    //初始化之前的最大特点是数据还没代理好，打印不到
  },
  created(){
    //初始化之后数据能被访问了
  },
  //3、在初始化后渲染模板
  //4、挂载阶段 挂在前和挂在后
  beforeMount(){
    //打印不出来
    console.log(this.$refs.xxx)
  },
  //5、创建 vm.$el并且替代el挂载点
  mounted(){
    //可以打印出来  这个钩子用得最多，一般用于发送ajax请求获取数据 还用于开启定时器 添加一些事件
    console.log(this.$refs.xxx)
    let timer = setInterval(()=>{
      this.isShow = !this.isShow
    },2000)
  },
  //前两个阶段完成 代表初始化展示页面已经完成
  /*
  页面更新阶段 页面数据更新之前和页面数据更新  不是vm的数据
  */
  beforeUpdate(){
    //页面更新前 vm的数据已经做了更新了，但是此时页面的数据还没有更新过来
  },
  updated(){
    //页面更新后 页面的数据和vm的数据保持了一致
  },
  //销毁阶段 销毁之前和销毁之后 销毁实例
  beforeDestroy(){
    //  一般这个钩子用的也是比较频繁，通常是在销毁前解绑事件监听 取消定时器等操作
    clearInterval(this.timer) //定时器管理模块会把这个定时器给停止，但是并不会把这个编号从timer当中销毁
    this.timer = null//把定时器编号也销毁
  },
  destroyed(){
    //没什么用
  }
}).mount('#app')

</script>
~~~

# 4、Vue的其他特性

## 4.1 过度动画

![Transition Diagram](001-VUE.assets/transition.png)

~~~vue
<transition name='slide'> //动画区块要在transition标签内
  <p v-if='show'></p>
</transition>

<button @click='isShow=!isShow'>
  点击切换
</button>

<script>
//从无到有叫进入  v-enter v-enter-active v-enter-to
//从有到无叫离开  v-leave v-leave-active v-leave-to
  //其中v为transition中的name属性指定
new Vue({
  el:'#app',
  data(){
    return:{
      isShow:true
    }
  }
})
</script>

<style>
  //进入阶段 slide是transition标签内定义的名称
  .slide-enter{
    height:0;
    opacity:0;
    background-color:black;
  }
  .slide-enter-active{
    transition:all 5s;
  }
  .slide-enter-to{
    height:500px;
    opacity:1;
    bakground-color:hotpink;
  }
</style>
~~~

## 4.2 自定义指令

~~~js
//自定义指令分为全局指令和局部指令

//全局指令是定义在Vue实例外面的
Vue.directive('upper',function(node,bindings){
	node.textContent = bindings.value.toUpperCase() //自定义指定的功能
})//参数 1 指令名称（不包含v- 只能是全小写）2 回调函数（使用这个指令的节点；这个指令使用的表达式的值以及表达式的集合）

//局部指令是定义Vue实例内部的，仅在定义实例内部才能使用
directives:{
  upper(node,bindings){
    node.textContent = bindings.value.toUpperCase()
  }
}
~~~

## 4.3 自定义过滤器

~~~js
//vue当中的过滤器可以理解成是为了让数据进一步的计算，得到最终的结果
{{timeNow|timeFormat}}//把timeNow的数据传给timeFormat中的value值

data(){
  return:{
    timeNow:Date.now()
  }
}
//定义全局过滤器
Vue.filter('timeFormat',fuction(value){
	return moment(value).format('YYYY-MM-DD hh:mm:ss')
})

//定义局部过滤器
filters('timeFormat',function(value){//value固定第一个
  return moment(value).format('YYYY-MM-DD hh:mm:ss')
})

~~~

## 4.4 自定义插件

~~~js
(function(w){
  //一个插件最终是一个对象
  let MyPlugin = {}
  //一个插件必须要有一个install方法
  MyPlugin.install = function(Vue,options){
    //1、添加全局方法或property
    Vue.myGlobalMethod = funciton(){
      //逻辑
    }
    //2、添加全局资源 方法名 功能
    Vue.directive('upper',function(el,bindings){
      el.textContent=bindings.value.toUpperCase()
    })
    //3、注入组件选项
    Vue.mixin({
      created:funciton(){
			//逻辑
    	}
    })
    //4、添加实例方法
    Vue.prototype.$myMethod = function(methodOptions){
      //逻辑
    }
  }
  //将插件挂载到window身上，暴露出去
  w.Plugin = MyPlugin
})(window)

Vue.use(MyPlugin) //使用自定义插件 声明使用插件 本质是在自动调用插件中的install方法
~~~

## 4.5 定义非单文件组件

在模板文件内部定义自己的组件

~~~js
<mybutton></mybutton>


//1、定义全局组件 本质上是根据一个配置对象定义返回一个函数，后期是当构造函数使用
	//麻烦写法
	cont VueComponent = Vue.extend({
    //组件配置对象和Vue的配置对象很相似，除了el
    data(){//组件的配置独享当中data只能写函数
      return{
        count:0
      }
    },
    template:'<div><h2></h2><button @click='count++'></button></div>'//模板中的两个组件一般用同一个标签包裹起来
  })
//2、注册（全局注册和局部注册）本质是吧一个标签的名称和刚才定义出来的函数绑定在一起
Vue.component('mybutton',VueComponent)//自动将标签名字和组件绑定起来
//3、使用
//每次写标签使用的时候，都会偷偷的实例化出来的函数的实例化对象，被称作是组件对象也就是说每一个组件标签背后都会对应自己的组件对象在支撑着


//简单写法
//1、定义带注册 本质上 内部还是使用extend生成一个函数，然后再去和mybutton绑定
Vue.component('mybutton',{
  data(){
    retrurn{
      count:0
    }
  },
  template:'<div><h2></h2><button @click='count++'></button></div>
})
//2、使用

//局部注册
new Vue({
  el:'#app',
  components:{
    mybutton:{
      data(){
        retrurn{
          count:0
        }
      },
      template:'<div><h2></h2><button @click='count++'></button></div>
    }
  }
})
~~~

## 4.6 定义单文件组件

在components文件夹中定义单文件组件（文件一般命名为 组件名.vue）

~~~js
<div>
	<button>
  </button>  
</div>

//定义
export default{
  //一个.vue文件通常说是一个组件，但是本质不是，本质其实是定义组件的配置对象
  name:'',
  data(){
    return{
      count:0
    }
  }
}

//注册
import Mybutton from './filepath/filename.vue' //拿到了一个定义组件的配置对象

export default {
  neme:'',
  components:{
    //在这里才使用导入进来的配置对象定义带注册了一个组件
    //单文件必须双标签，并且命名大驼峰
    Mybutton
  }
}

//使用
import App from './..'

new Vue({
  componnets:{
    App//定义带注册App
  },
  template:'<></>'
}).mount('#app')
~~~

